\documentclass[12pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{palatino}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage[dvips]{graphics}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{multicol}
\usepackage{url}
\usepackage{html}
\usepackage{color}

 \definecolor{violet}{rgb}{0.5,0,0.5}
 
\setlength{\topmargin}{0cm}
\setlength{\headheight}{1cm}
\setlength{\textheight}{21cm}
\setlength{\textwidth}{16cm}
\setlength{\oddsidemargin}{0cm}
\setlength{\evensidemargin}{0cm}
\setlength{\columnsep}{0.125in}
\setlength{\columnseprule}{0.5pt}
\setlength{\footskip}{1cm}
\sloppy

%--------------------------------- page style --------------------------------
\pagestyle{fancy}
\rhead{}
\lhead{}
\rfoot{\thepage}
\lfoot{}
\cfoot{}
%---------------------------------- document ---------------------------------
\date   {}
\title  {Patterns Module User's Manual}
\author {Roselyne Chotin-Avot}

\begin{document}

\setlength{\footrulewidth}{0.6pt}
\maketitle

%%\begin{htmlonly}
%%  \htmlrule
%%  \noindent La version imprimable de ce document est disponible ici~: \\
%%  \begin{center}
%%    \hyperref[hyper]{http://asim.lip6.fr/~jpc/M1-C++/TME/6/TME6.pdf}{}{}
%%                    {http://asim.lip6.fr/~jpc/M1-C++/TME/6/TME6.pdf}
%%  \end{center}
%%\end{htmlonly}

\tableofchildlinks
\htmlrule

\section{Description}
The patterns module of \emph{Stratus} is a set of \emph{Python} classes and 
methods that allows a procedural description of input pattern  file  for  the 
logic  simulator. The \emph{Stratus} \verb-Pattern- method produces a pattern 
description file as output. The file generated by \verb-Pattern- method is in 
pat format, so IT IS STRONGLY RECOMMENDED TO SEE pat(5) manual BEFORE TO USE 
IT.

\section{Syntax}
From a user point of view, \verb-Pattern- method is a pattern description 
language using all standard \emph{Python} facilities. Here follows the 
description of the \verb-Pattern- method.\\
A pat format file can be divided in two parts : declaration and description 
part.\\
The declaration part is the list of inputs, outputs, internal signals and 
registers. Inputs are to be forced to a certain  value and all the others are 
to be observed during simulation.\\
The description part is a set of patterns, where each pattern defines the value 
of inputs and outputs. The pattern number represents actually the absolute time 
for the simulator.\\
Similarly, a \verb-Pattern- method can be divided in two parts : declaration 
and description part. Methods related  to  the  declaration must be called 
before any function related to the description part.

\subsection{Declaration part}
The  first  thing  you  should do in this part is to instantiate the class
\verb-Patwrite- to have access to all patterns declaration and description 
methods. The constructor of this class take as parameters the name of pattern
output file and the \emph{Stratus} cell that is described (see \verb-PatWrite-
\ref{patwrite}).\\
Then, this part allows you to declare the inputs, the outputs, and internal 
observing points (see \verb-declar-\ref{declar} and \verb-declar_interface- 
\ref{declar_interface}).

\subsection{Description part}
After all signals are declared, you can begin the description part (see
\verb-pattern_begin- \ref{pattern_begin}). In this part you have to define 
input values which are to be applied to the inputs of the circuit or output 
values which are to be compare with the values produced during the simulation. 
(see \verb-affect- \ref{affect}, \verb-affect_any- \ref{affect_any}, 
\verb-affect_int- \ref{affect_int} and \verb-affect_fix- \ref{affect_fix}).
\verb-Pattern- method describes the stimulus by event : only signal transitions 
are described. After each event there is a new input in the pattern file (see
\verb-addpat- \ref{addpat}). Last thing you should do in this part is to 
generate the output file (see \verb-pattern_end- \ref{pattern_end}).

\section{Methods}
\subsection{PatWrite}
\label{patwrite}
This class is used to create patterns for \emph{Stratus} models. Currently
it only supports Alliance ".pat" pattern format. Patterns time stamps are in 
the "absolute date" format, "relative date" isn't allowed. Legal time unit are 
ps (default), ns, us and ms. The constructor takes as parameters the pattern 
output filename and an optional reference to Stratus cell.

\subsection{declar}
\label{declar}
Adds a connector from a Stratus model to the pattern interface. Writes the 
corresponding connector declaration in the pattern file with name, arity and 
direction automatically extracted from the connector properties.\\
Supported Stratus connectors are:
\begin{itemize}
\item{SignalIn,}
\item{SignalOut (only supported if used as an output),}
\item{VddIn,}
\item{VssIn,}
\item{CkIn,}
\item{SignalInOut,}
\item{TriState (always an output),}
\item{Signals.}
\end{itemize}

\subsubsection{Parameters}
\begin{itemize}
\item{connector : can either be a reference to a stratus net or a string 
containing the name of the stratus net.}
\item{format : optional format for the connectors values into the pattern file, 
accepted values are :}
   \begin{itemize}
   \item{'B': binary (default),}
   \item{'X': hexadecimal,}
   \item{'O': octal.}
   \end{itemize}
\end{itemize}

\subsection{declar\_interface}
\label{declar_interface}
Adds all the connectors from a Stratus model to the pattern interface. Write 
the corresponding connector declaration in the pattern file with name, arity 
and direction directly taken from the connector proprieties.\\

\subsubsection{Parameters}
\begin{itemize}
\item{cell : the tested Stratus model reference. Optional if a reference to the
tested Stratus model was given during instanciation\ref{patwrite}.}
\item{format : optional format for the connectors values into the pattern file, 
accepted values are :}
   \begin{itemize}
   \item{'B': binary (default),}
   \item{'X': hexadecimal,}
   \item{'O': octal.}
   \end{itemize}
\end{itemize}

\subsection{declar}
\label{declar}
Affect a string value to a connector.

\subsubsection{Parameters}
\begin{itemize}
\item{connector : \emph{Stratus} connector}
\item{value : string to affect to connector}
\end{itemize}

\subsection{affect\_int}
\label{affect_int}
Affect an integer (CA2) value to a connector. Convert the 2's complement value 
to the corresponding binary value. The binary size is taken from the connector 
arity. If the connector is an output, the binary value is preceded by "?".

\subsubsection{Parameters}
\begin{itemize}
\item{connector : \emph{Stratus} connector.}
\item{value : 2's complement value to affect to the connector.}
\end{itemize}

\subsection{affect\_fix}
\label{affect_fix}
Affect a fixed point value to a connector. Convert the floating point input 
value to the corresponding fixed point value with 
word\_length=connector.arity() and integer\_word\_length=iwl. If the connector 
is an output, the binary value is preceded by "?".

\subsubsection{Parameters}
\begin{itemize}
\item{connector : \emph{Stratus} connector.}
\item{value : floating point value to convert and asign to connector.}
\item{iwl : integer word length}
\end{itemize}

\subsection{affect\_any}
\label{affect_any}
Disable comparison between this connector value and the one calculated during 
simulation.

\subsubsection{Parameters}
\begin{itemize}
\item{connector : \emph{Stratus} connector.}
\end{itemize}

\subsection{addpat}
\label{addpat}
Adds a pattern in the pattern file.

\subsection{pattern\_begin}
\label{pattern_begin}
Mark the end of the interface declaration and the beginning of the test 
vectors.

\subsection{pattern\_end}
\label{pattern_end}
Mark the end of the test vectors and of the patterns file.

\section{Example}
\verb-Pattern- method for an addaccu
\begin{verbatim}
def Pattern(self):
    # initialisation
    pat = PatWrite(self._name+'.pat',self)

    # declaration of ports
    pat.declar(self.ck, 'B')
    pat.declar(self.load, 'B')
    pat.declar(self.input, 'X')
    pat.declar(self.output, 'X')
    pat.declar(self.vdd, 'B')
    pat.declar(self.vss, 'B')
    
    # use of pat.declar_interface(self) has the same effect

    # description beginning
    pat.pattern_begin()

    # affect vdd and vss values
    pat.affect_int(self.vdd,1)
    pat.affect_int(self.vss,0)

    # first pattern : load an initial value
    pat.affect_int(self.input,5)
    pat.affect_int(self.load,1)
    pat.affect_int(self.ck,0)
    # add the pattern in the pattern file
    pat.addpat()
    # compute next event
    pat.affect_int(self.ck,1)
    pat.addpat()

    # compute 22 cycle of accumulation
    pat.affect_int(self.load,0)
    for i in range(1,22):
       pat.affect_int(self.ck,0)
       pat.addpat()
       pat.affect_int(self.ck,1)
       pat.affect_int(self.output,i+5)
       pat.addpat()

    # end of the description
    pat.pattern_end()
\end{verbatim}

\end{document}
