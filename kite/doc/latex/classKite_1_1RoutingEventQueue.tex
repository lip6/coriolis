\hypertarget{classKite_1_1RoutingEventQueue}{}\subsection{Routing\+Event\+Queue Class Reference}
\label{classKite_1_1RoutingEventQueue}\index{Routing\+Event\+Queue@{Routing\+Event\+Queue}}


The priority Queue of \hyperlink{classKite_1_1RoutingEvent}{Routing\+Event}.  


\subsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classKite_1_1RoutingEventQueue_a67dd3abe4f9f4f32e91dfaa9573976ca}{Routing\+Event\+Queue} ()
\item 
\hyperlink{classKite_1_1RoutingEventQueue_a28ed9894863ae1029f16744a86d4bfab}{$\sim$\+Routing\+Event\+Queue} ()
\item 
bool \hyperlink{classKite_1_1RoutingEventQueue_a644718bb2fb240de962dc3c9a1fdf0dc}{empty} () const
\item 
size\+\_\+t \hyperlink{classKite_1_1RoutingEventQueue_a259cb5a711406a8c3e5d937eb9350cca}{size} () const
\item 
unsigned int \hyperlink{classKite_1_1RoutingEventQueue_a85befa55ce7e51c7067f4f7cb29acc0a}{get\+Top\+Event\+Level} () const
\item 
\hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} $\ast$ \hyperlink{classKite_1_1RoutingEventQueue_af1b85d0b49565932c55ec55625cd8838}{pop} ()
\item 
void \hyperlink{classKite_1_1RoutingEventQueue_a7f5a051812b2925dc3c1cca8b2011237}{load} (const vector$<$ \hyperlink{classKite_1_1TrackElement}{Track\+Element} $\ast$$>$ \&)
\item 
void \hyperlink{classKite_1_1RoutingEventQueue_af0813b67c9fc72d960f7e512e9403d57}{add} (\hyperlink{classKite_1_1TrackElement}{Track\+Element} $\ast$, unsigned int level)
\item 
void \hyperlink{classKite_1_1RoutingEventQueue_ac802427673567526d06af911e94f7216}{push} (\hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} $\ast$)
\item 
void \hyperlink{classKite_1_1RoutingEventQueue_afd2fa6d6f5d90c472bea9befa97d955d}{repush} (\hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} $\ast$)
\item 
void \hyperlink{classKite_1_1RoutingEventQueue_a4fb0022d3e8f91a862b5f6438b7f8dad}{repush\+Invalidateds} ()
\item 
void \hyperlink{classKite_1_1RoutingEventQueue_ad55316f5135cdae6aa6c5a763f6c3473}{commit} ()
\item 
void \hyperlink{classKite_1_1RoutingEventQueue_ac8bb3912a3ce86b15842e79d0b421204}{clear} ()
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
The priority Queue of \hyperlink{classKite_1_1RoutingEvent}{Routing\+Event}. 

\hypertarget{classKite_1_1RoutingEventQueue_secImplRoutingEventQueue}{}\subsubsection{Implementation Details}\label{classKite_1_1RoutingEventQueue_secImplRoutingEventQueue}
The \hyperlink{classKite_1_1RoutingEventQueue}{Routing\+Event\+Queue} is build upon a S\+TL multiset$<$$>$ and is sorted according to the \hyperlink{classKite_1_1RoutingEvent_1_1Key}{Routing\+Event\+::\+Key} attribute of the event. The key attribute has been designed specifically to be used with this queue. It provides the features\+:
\begin{DoxyItemize}
\item Sort the \hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} according to their priority. Higher priority mainly means more constrained segment, which must be routed first.
\item The attributes of \hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} may change while inserted in the queue. The key provide a cached value of those attributes ensuring a stable sorting order.
\end{DoxyItemize}

For more details about the sorting order, refer to \hyperlink{classKite_1_1RoutingEvent_1_1Key}{Routing\+Event\+::\+Key}.

{\bfseries Insertion, Reinsertion \& Commit}

When pushing a new event into the queue, the actual insertion into the multimap is delayed until the next call to {\ttfamily Routing\+Event\+::commit()}. The to be inserted events are stored into a request set which is processed when commit is called. At commit time, the \hyperlink{classKite_1_1RoutingEvent_1_1Key}{Routing\+Event\+::\+Key} cache is updated just before inserting the element.

When repushing an event, the event is immediatly withdrawn from the queue and put into the request set.

{\bfseries Mutiple Event for one Segment}

As \hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} can be cloned, there may be more than one event pointing to a segment. But there must be {\itshape only one active event}, the one which is pointed to by the segment. As a result, there maybe multiple events for an unique segment in the queue, but {\itshape only one active event}, the one that will be processed. 

\subsubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classKite_1_1RoutingEventQueue_a67dd3abe4f9f4f32e91dfaa9573976ca}\label{classKite_1_1RoutingEventQueue_a67dd3abe4f9f4f32e91dfaa9573976ca}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!Routing\+Event\+Queue@{Routing\+Event\+Queue}}
\index{Routing\+Event\+Queue@{Routing\+Event\+Queue}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{Routing\+Event\+Queue()}{RoutingEventQueue()}}
{\footnotesize\ttfamily \hyperlink{classKite_1_1RoutingEventQueue}{Routing\+Event\+Queue} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Contructor, create an empty queue. \mbox{\Hypertarget{classKite_1_1RoutingEventQueue_a28ed9894863ae1029f16744a86d4bfab}\label{classKite_1_1RoutingEventQueue_a28ed9894863ae1029f16744a86d4bfab}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!````~Routing\+Event\+Queue@{$\sim$\+Routing\+Event\+Queue}}
\index{````~Routing\+Event\+Queue@{$\sim$\+Routing\+Event\+Queue}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{$\sim$\+Routing\+Event\+Queue()}{~RoutingEventQueue()}}
{\footnotesize\ttfamily $\sim$\hyperlink{classKite_1_1RoutingEventQueue}{Routing\+Event\+Queue} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Destructor.

\begin{DoxyParagraph}{Remark\+:}
The destruction of the queue do not delete the \hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} that may still be in it (they shouldn\textquotesingle{}t an a warning is issued). 
\end{DoxyParagraph}


\subsubsection{Member Function Documentation}
\mbox{\Hypertarget{classKite_1_1RoutingEventQueue_a644718bb2fb240de962dc3c9a1fdf0dc}\label{classKite_1_1RoutingEventQueue_a644718bb2fb240de962dc3c9a1fdf0dc}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!empty@{empty}}
\index{empty@{empty}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily bool empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

{\bfseries Returns\+:} {\bfseries true} if there is the queue is empty. 

Referenced by Negociate\+Window\+::compute\+Wirelength().

\mbox{\Hypertarget{classKite_1_1RoutingEventQueue_a259cb5a711406a8c3e5d937eb9350cca}\label{classKite_1_1RoutingEventQueue_a259cb5a711406a8c3e5d937eb9350cca}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!size@{size}}
\index{size@{size}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily size\+\_\+t size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

{\bfseries Returns\+:} The number of events in the queue. 

Referenced by Routing\+Event\+Queue\+::clear(), and Negociate\+Window\+::compute\+Wirelength().

\mbox{\Hypertarget{classKite_1_1RoutingEventQueue_a85befa55ce7e51c7067f4f7cb29acc0a}\label{classKite_1_1RoutingEventQueue_a85befa55ce7e51c7067f4f7cb29acc0a}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!get\+Top\+Event\+Level@{get\+Top\+Event\+Level}}
\index{get\+Top\+Event\+Level@{get\+Top\+Event\+Level}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{get\+Top\+Event\+Level()}{getTopEventLevel()}}
{\footnotesize\ttfamily unsigned int get\+Top\+Event\+Level (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

{\bfseries Returns\+:} The greatest event level the queue has ever reached (always increasing, starting from zero). \mbox{\Hypertarget{classKite_1_1RoutingEventQueue_af1b85d0b49565932c55ec55625cd8838}\label{classKite_1_1RoutingEventQueue_af1b85d0b49565932c55ec55625cd8838}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!pop@{pop}}
\index{pop@{pop}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{pop()}{pop()}}
{\footnotesize\ttfamily \hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} $\ast$ pop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Remove the top element of the queue (i.\+e. the one with the highest priority) and return it. If the queue is empty, {\ttfamily N\+U\+LL} is returned. 

Referenced by Negociate\+Window\+::compute\+Wirelength().

\mbox{\Hypertarget{classKite_1_1RoutingEventQueue_a7f5a051812b2925dc3c1cca8b2011237}\label{classKite_1_1RoutingEventQueue_a7f5a051812b2925dc3c1cca8b2011237}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!load@{load}}
\index{load@{load}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{load()}{load()}}
{\footnotesize\ttfamily void load (\begin{DoxyParamCaption}\item[{const vector$<$ \hyperlink{classKite_1_1TrackElement}{Track\+Element} $\ast$$>$ \&}]{segments }\end{DoxyParamCaption})}

Load a whole vector of \hyperlink{classKite_1_1TrackElement}{Track\+Element} into the queue, for each element\+:
\begin{DoxyItemize}
\item Create a \hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} linked to the element. To be reviewed\+: replace any previous event.
\item Insert the new \hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} into the queue.
\end{DoxyItemize}

{\itshape No commit is needed after this operation.} \mbox{\Hypertarget{classKite_1_1RoutingEventQueue_af0813b67c9fc72d960f7e512e9403d57}\label{classKite_1_1RoutingEventQueue_af0813b67c9fc72d960f7e512e9403d57}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!add@{add}}
\index{add@{add}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{add()}{add()}}
{\footnotesize\ttfamily void add (\begin{DoxyParamCaption}\item[{\hyperlink{classKite_1_1TrackElement}{Track\+Element} $\ast$}]{element,  }\item[{unsigned int}]{level }\end{DoxyParamCaption})}

Create a new \hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} in the queue with {\ttfamily level}, associated to {\ttfamily element}. A commit is needed afterwards.

To be reviewed\+: replace any previous event on element. \mbox{\Hypertarget{classKite_1_1RoutingEventQueue_ac802427673567526d06af911e94f7216}\label{classKite_1_1RoutingEventQueue_ac802427673567526d06af911e94f7216}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!push@{push}}
\index{push@{push}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{push()}{push()}}
{\footnotesize\ttfamily void push (\begin{DoxyParamCaption}\item[{\hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} $\ast$}]{event }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Push a \hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} in the queue. Effective only after the next commit. 

Referenced by Routing\+Event\+Queue\+::add(), and Routing\+Event\+Queue\+::repush().

\mbox{\Hypertarget{classKite_1_1RoutingEventQueue_afd2fa6d6f5d90c472bea9befa97d955d}\label{classKite_1_1RoutingEventQueue_afd2fa6d6f5d90c472bea9befa97d955d}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!repush@{repush}}
\index{repush@{repush}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{repush()}{repush()}}
{\footnotesize\ttfamily void repush (\begin{DoxyParamCaption}\item[{\hyperlink{classKite_1_1RoutingEvent}{Routing\+Event} $\ast$}]{event }\end{DoxyParamCaption})}

Force a complete queue re-\/insertion for {\ttfamily event}. The event is immediatly withdrawn from the queue and put into the insertion request set.

If the {\ttfamily event} is not already in the queue, works like \hyperlink{classKite_1_1RoutingEventQueue_ac802427673567526d06af911e94f7216}{Routing\+Event\+Queue\+::push()}. 

Referenced by Routing\+Event\+Queue\+::repush\+Invalidateds(), and Routing\+Event\+::reschedule().

\mbox{\Hypertarget{classKite_1_1RoutingEventQueue_a4fb0022d3e8f91a862b5f6438b7f8dad}\label{classKite_1_1RoutingEventQueue_a4fb0022d3e8f91a862b5f6438b7f8dad}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!repush\+Invalidateds@{repush\+Invalidateds}}
\index{repush\+Invalidateds@{repush\+Invalidateds}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{repush\+Invalidateds()}{repushInvalidateds()}}
{\footnotesize\ttfamily void repush\+Invalidateds (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Using the list of invalidated segments from the \hyperlink{classKite_1_1Session}{Session}, repush them if\+:
\begin{DoxyItemize}
\item They have an associated event.
\item The event is not {\itshape unimplemented}, {\itshape disabled} or {\itshape processed}. 
\end{DoxyItemize}

Referenced by Routing\+Event\+::process().

\mbox{\Hypertarget{classKite_1_1RoutingEventQueue_ad55316f5135cdae6aa6c5a763f6c3473}\label{classKite_1_1RoutingEventQueue_ad55316f5135cdae6aa6c5a763f6c3473}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!commit@{commit}}
\index{commit@{commit}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{commit()}{commit()}}
{\footnotesize\ttfamily void commit (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Process the insertion request set and actually insert it\textquotesingle{}s elements into the queue. Perform a Routing\+Event\+::key update prior to insertion. 

Referenced by Negociate\+Window\+::compute\+Wirelength(), and Routing\+Event\+::process().

\mbox{\Hypertarget{classKite_1_1RoutingEventQueue_ac8bb3912a3ce86b15842e79d0b421204}\label{classKite_1_1RoutingEventQueue_ac8bb3912a3ce86b15842e79d0b421204}} 
\index{Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}!clear@{clear}}
\index{clear@{clear}!Kite\+::\+Routing\+Event\+Queue@{Kite\+::\+Routing\+Event\+Queue}}
\paragraph{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily void clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Empty the queue. Issue a warning if the queue is not empty (i.\+e. some events remains to be processeds). 

Referenced by Routing\+Event\+Queue\+::$\sim$\+Routing\+Event\+Queue().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Routing\+Event\+Queue.\+h\item 
Routing\+Event\+Queue.\+cpp\item 
Routing\+Event\+Queue.\+dox\end{DoxyCompactItemize}
